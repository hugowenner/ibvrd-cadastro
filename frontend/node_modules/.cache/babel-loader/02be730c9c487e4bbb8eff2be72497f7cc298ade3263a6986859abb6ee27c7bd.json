{"ast":null,"code":"var _jsxFileName = \"/home/hugowenner/Documentos/ibvrd-cadastro/frontend/src/contexts/PessoaContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { api } from '../services/api';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const PessoaContext = /*#__PURE__*/createContext();\nexport const PessoaProvider = ({\n  children\n}) => {\n  _s();\n  const [pessoas, setPessoas] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // Função para buscar pessoas da API\n  const fetchPessoas = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await api.getPessoas();\n      setPessoas(response.data);\n    } catch (err) {\n      console.error(\"Falha ao buscar pessoas:\", err);\n      setError(\"Não foi possível carregar a lista de pessoas. Tente novamente mais tarde.\");\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Carrega os dados na montagem do componente\n  useEffect(() => {\n    fetchPessoas();\n  }, [fetchPessoas]);\n\n  // Adiciona uma nova pessoa com atualização otimista\n  const addPessoa = async pessoaData => {\n    // Cria um ID temporário para a atualização otimista\n    const tempId = `temp-${Date.now()}`;\n    const optimisticPessoa = {\n      ...pessoaData,\n      id: tempId\n    };\n    try {\n      // Atualização otimista: adiciona a pessoa à lista antes da resposta da API\n      setPessoas(prevPessoas => [...prevPessoas, optimisticPessoa]);\n      const response = await api.addPessoa(pessoaData);\n\n      // Substitui a pessoa temporária pela resposta real da API\n      setPessoas(prevPessoas => prevPessoas.map(pessoa => pessoa.id === tempId ? response.data : pessoa));\n      return response.data;\n    } catch (err) {\n      console.error(\"Falha ao adicionar pessoa:\", err);\n\n      // Reverte a atualização otimista em caso de erro\n      setPessoas(prevPessoas => prevPessoas.filter(pessoa => pessoa.id !== tempId));\n      throw new Error(\"Não foi possível cadastrar a pessoa. Tente novamente.\");\n    }\n  };\n\n  // Atualiza uma pessoa existente\n  const updatePessoa = async (id, pessoaData) => {\n    try {\n      const response = await api.updatePessoa(id, pessoaData);\n      setPessoas(prevPessoas => prevPessoas.map(pessoa => pessoa.id === id ? response.data : pessoa));\n      return response.data;\n    } catch (err) {\n      console.error(\"Falha ao atualizar pessoa:\", err);\n      throw new Error(\"Não foi possível atualizar os dados da pessoa. Tente novamente.\");\n    }\n  };\n\n  // Exclui uma pessoa com atualização otimista\n  const deletePessoa = async id => {\n    // Armazena a pessoa original caso precise reverter\n    const originalPessoa = pessoas.find(pessoa => pessoa.id === id);\n    try {\n      // Atualização otimista: remove a pessoa antes da resposta da API\n      setPessoas(prevPessoas => prevPessoas.filter(pessoa => pessoa.id !== id));\n      await api.deletePessoa(id);\n    } catch (err) {\n      console.error(\"Falha ao excluir pessoa:\", err);\n\n      // Reverte a atualização otimista em caso de erro\n      if (originalPessoa) {\n        setPessoas(prevPessoas => [...prevPessoas, originalPessoa]);\n      }\n      throw new Error(\"Não foi possível excluir a pessoa. Tente novamente.\");\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(PessoaContext.Provider, {\n    value: {\n      pessoas,\n      loading,\n      error,\n      fetchPessoas,\n      addPessoa,\n      updatePessoa,\n      deletePessoa\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 105,\n    columnNumber: 9\n  }, this);\n};\n_s(PessoaProvider, \"WQE+f6SF70IbA1RC/5xFNZldP7Q=\");\n_c = PessoaProvider;\nPessoaProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\nvar _c;\n$RefreshReg$(_c, \"PessoaProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","PropTypes","api","jsxDEV","_jsxDEV","PessoaContext","PessoaProvider","children","_s","pessoas","setPessoas","loading","setLoading","error","setError","fetchPessoas","response","getPessoas","data","err","console","addPessoa","pessoaData","tempId","Date","now","optimisticPessoa","id","prevPessoas","map","pessoa","filter","Error","updatePessoa","deletePessoa","originalPessoa","find","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","propTypes","node","isRequired","$RefreshReg$"],"sources":["/home/hugowenner/Documentos/ibvrd-cadastro/frontend/src/contexts/PessoaContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { api } from '../services/api';\n\nexport const PessoaContext = createContext();\n\nexport const PessoaProvider = ({ children }) => {\n    const [pessoas, setPessoas] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    // Função para buscar pessoas da API\n    const fetchPessoas = useCallback(async () => {\n        try {\n            setLoading(true);\n            setError(null);\n            const response = await api.getPessoas();\n            setPessoas(response.data);\n        } catch (err) {\n            console.error(\"Falha ao buscar pessoas:\", err);\n            setError(\"Não foi possível carregar a lista de pessoas. Tente novamente mais tarde.\");\n        } finally {\n            setLoading(false);\n        }\n    }, []);\n\n    // Carrega os dados na montagem do componente\n    useEffect(() => {\n        fetchPessoas();\n    }, [fetchPessoas]);\n\n    // Adiciona uma nova pessoa com atualização otimista\n    const addPessoa = async (pessoaData) => {\n        // Cria um ID temporário para a atualização otimista\n        const tempId = `temp-${Date.now()}`;\n        const optimisticPessoa = { ...pessoaData, id: tempId };\n        \n        try {\n            // Atualização otimista: adiciona a pessoa à lista antes da resposta da API\n            setPessoas(prevPessoas => [...prevPessoas, optimisticPessoa]);\n            \n            const response = await api.addPessoa(pessoaData);\n            \n            // Substitui a pessoa temporária pela resposta real da API\n            setPessoas(prevPessoas => \n                prevPessoas.map(pessoa => \n                    pessoa.id === tempId ? response.data : pessoa\n                )\n            );\n            \n            return response.data;\n        } catch (err) {\n            console.error(\"Falha ao adicionar pessoa:\", err);\n            \n            // Reverte a atualização otimista em caso de erro\n            setPessoas(prevPessoas => \n                prevPessoas.filter(pessoa => pessoa.id !== tempId)\n            );\n            \n            throw new Error(\"Não foi possível cadastrar a pessoa. Tente novamente.\");\n        }\n    };\n\n    // Atualiza uma pessoa existente\n    const updatePessoa = async (id, pessoaData) => {\n        try {\n            const response = await api.updatePessoa(id, pessoaData);\n            \n            setPessoas(prevPessoas => \n                prevPessoas.map(pessoa => \n                    pessoa.id === id ? response.data : pessoa\n                )\n            );\n            \n            return response.data;\n        } catch (err) {\n            console.error(\"Falha ao atualizar pessoa:\", err);\n            throw new Error(\"Não foi possível atualizar os dados da pessoa. Tente novamente.\");\n        }\n    };\n\n    // Exclui uma pessoa com atualização otimista\n    const deletePessoa = async (id) => {\n        // Armazena a pessoa original caso precise reverter\n        const originalPessoa = pessoas.find(pessoa => pessoa.id === id);\n        \n        try {\n            // Atualização otimista: remove a pessoa antes da resposta da API\n            setPessoas(prevPessoas => prevPessoas.filter(pessoa => pessoa.id !== id));\n            \n            await api.deletePessoa(id);\n        } catch (err) {\n            console.error(\"Falha ao excluir pessoa:\", err);\n            \n            // Reverte a atualização otimista em caso de erro\n            if (originalPessoa) {\n                setPessoas(prevPessoas => [...prevPessoas, originalPessoa]);\n            }\n            \n            throw new Error(\"Não foi possível excluir a pessoa. Tente novamente.\");\n        }\n    };\n\n    return (\n        <PessoaContext.Provider value={{ \n            pessoas, \n            loading, \n            error, \n            fetchPessoas,\n            addPessoa, \n            updatePessoa, \n            deletePessoa \n        }}>\n            {children}\n        </PessoaContext.Provider>\n    );\n};\n\nPessoaProvider.propTypes = {\n    children: PropTypes.node.isRequired\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}